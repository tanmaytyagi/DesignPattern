## Battleship Approach and Class Order

### Goal
Build a minimal, clean OOP design with clear separation of concerns and easy extensibility for firing strategies.

### Design Overview (How It Works)
- `Battlefield` owns board size, side boundaries, ship placement validation, hit/miss resolution, and grid rendering.
- `Player` owns ships and holds a firing strategy.
- `Ship` is an immutable model that computes its occupied cells from a center coordinate.
- `GameService` orchestrates the game lifecycle and prints output.
- `FireStrategy` is an interface so strategies can be swapped without changing game logic.
- `RandomFireStrategy` is the default implementation.

### How the Game Is Played
- The board is an NxN grid split vertically: PlayerA uses the left half, PlayerB uses the right half.
- Both players place an equal number of square ships on their own half.
- Players take turns firing a missile at a single coordinate on the opponent's half.
- A hit destroys the entire ship; a miss switches the turn to the other player.
- No coordinate can be targeted more than once across the whole game.
- The game ends when all ships of one player are destroyed.

### What the Inputs Mean
- `initGame(N)`: `N` is the board size; must be even and > 0.
- `addShip(id, size, xA, yA, xB, yB)`:
  - `id`: unique ship identifier (used in output labels).
  - `size`: side length of the square ship (e.g., size 2 occupies 2x2 cells).
  - `xA, yA`: center coordinate of PlayerA's ship on the left half.
  - `xB, yB`: center coordinate of PlayerB's ship on the right half.
  - Coordinates are 0-based with (0,0) at the top-left.
- `startGame()`: begins turns with PlayerA.
- `viewBattleField()`: prints the full grid with occupied cells labeled.

### Recommended Class Writing Order
Start from simple models, then core logic, then orchestration:

1) **Value Objects / Enums**
   - `Coordinate`: immutable x,y pair with `equals`/`hashCode`.
   - `Side`: enum for LEFT/RIGHT, with labels `A` and `B`.

2) **Core Domain Models**
   - `Ship`: immutable model; computes its occupied cells based on `size` and `center`.
   - `Player`: holds ships, side, and firing strategy.

3) **Core Game Logic**
   - `Battlefield`: validates placement, stores occupancy, resolves hits, renders grid.

4) **Strategy Abstraction**
   - `FireStrategy`: interface that returns the next coordinate.
   - `RandomFireStrategy`: default implementation (random valid target).

5) **Game Orchestration**
   - `GameService`: implements `initGame`, `addShip`, `startGame`, `viewBattleField`.

6) **Entry Point**
   - `Main`: shows sample usage.

### Why This Order Works
- Early classes are stable building blocks; later classes depend on them.
- `Battlefield` only needs models, so it can be built before services.
- Strategies are cleanly isolated, so they can be changed without touching `GameService`.

### File Map
- `model/Coordinate`, `model/Side`, `model/Ship`, `model/Player`
- `model/Battlefield`
- `strategy/FireStrategy`, `strategy/RandomFireStrategy`
- `service/GameService`
- `Main`
